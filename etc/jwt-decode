#!/usr/bin/env bash
# credit: https://willhaley.com/blog/generate-jwt-with-bash/
set -euo pipefail
secret="${ROOSET_JWT_SECRET}"
token=${1};

#
# JWT Decoder Bash Script
#


base64_encode()
{
    declare input=${1:-$(</dev/stdin)}
    # Use `tr` to URL encode the output from base64.
    printf '%s' "${input}" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'
}

base64_decode()
{
    declare input=${1:-$(</dev/stdin)}
    # A standard base64 string should always be `n % 4 == 0`. We made the base64
    # string URL safe when we created the JWT, which meant removing the `=`
    # signs that are there for padding. Now we must add them back to get the
    # proper length.
    remainder=$((${#input} % 4));
    if [ $remainder -eq 1 ];
    then
        >2& echo "fatal error. base64 string is unexepcted length"
    elif [[ $remainder -eq 2 || $remainder -eq 3 ]];
    then
        input="${input}$(for i in `seq $((4 - $remainder))`; do printf =; done)"
    fi
    printf '%s' "${input}" | base64 --decode
}

verify_signature()
{
    declare header_and_claims=${1}
    expected=$(echo "${header_and_claims}" | hmacsha256_encode | base64_encode)
    actual=${2}

    if [ "${expected}" != "${actual}" ]
    then
        exit 1
    fi
}

hmacsha256_encode()
{
    declare input=${1:-$(</dev/stdin)}
    printf '%s' "${input}" | openssl dgst -binary -sha256 -hmac "${secret}"
}


IFS='.' read -ra pieces <<< "$token"

declare header=${pieces[0]}
declare claims=${pieces[1]}
declare signature=${pieces[2]}

verify_signature "${header}.${claims}" "${signature}"

echo '{}' | jq -c \
  --argjson claims "$(echo -n ${claims} | base64_decode)"  \
  --argjson header "$(echo -n ${header} | base64_decode)"  \
  '
  .claims=$claims | .header=$header
  '
